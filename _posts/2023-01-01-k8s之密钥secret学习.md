---
layout:     post
title:      k8s的secret学习
subtitle:   k8s的secret学习
date:       2023-01-01
author:     eddie
header-img: img/home-bg-o.jpg
catalog: true
tags:
    - k8s
---

# kubernetes实战篇之创建密钥
****

Secrets是Kubernetes中一种对象类型，用来保存密码、私钥、口令等敏感信息。与直接将敏感信息嵌入image、pod相比，Secrets更安全、更灵活，用户对敏感信息的控制力更强。同Docker对敏感信息的管理类似，首先用户创建Secrets将敏感信息加密后保存在集群中，创建pod时通过volume、环境变量引用Secrets。

###  一：Secret类型


&ensp; &ensp; **Opaque类型**：使用base64编码存储信息，可以通过base64 --decode解码获得原始数据，因此安全性弱。
<br>
&ensp; &ensp; **kubernetes.io/dockerconfigjson类型**：用于存储docker registry的认证信息。作用于Docker registry(nexus)，用户下载docker镜像认证使用。
<br>
&ensp; &ensp; **kubernetes.io/service-account-token类型**：用于被 serviceaccount 引用。serviceaccout 创建时 Kubernetes 会默认创建对应的 secret。Pod 如果使用了 serviceaccount，对应的 secret 会自动挂载到 Pod 的 /run/secrets/kubernetes.io/serviceaccount 目录中。

###  **二：Secret创建**

###  &ensp; &ensp; 1. 通过 --from-literal： 每个 --from-literal 对应一个信息条目

```
kubectl create secret generic mysecret --from-literal=username=Test--from-literal=password=Test123456*
```



### &ensp; &ensp; 2. 通过 --from-file： 每个文件内容对应一个信息条目
```
echo -n Test> ./username
echo -n Test123456* > ./password
kubectl create secret generic mysecret --from-file=./username --from-file=./password
```

### &ensp; &ensp; 3. 通过 --from-env-file：文件 env.txt 中每行 Key=Value 对应一个信息条目
```
cat << EOF > env.txt
username=Test
password=Test123456*
EOF
kubectl create secret generic mysecret --from-env-file=env.txt
```


### &ensp; &ensp; 4. 通过YAML配置文件创建：（推荐方式）

### &ensp; &ensp;&ensp; &ensp;配置文件中的敏感数据必须是通过base64编码后的结果，因此需要获取base64编码后的值

```
[root@k8s-master ~]#  echo -n Test | base64
VGVzdA==
[root@k8s-master ~]#  echo -n Test123456* | base64
VGVzdDEyMzQ1Nio=
[root@k8s-master ~]#  vi secret-demo.yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
data:
  username: VGVzdA==
  password: VGVzdDEyMzQ1Nio=
```



### **三：在Pod中使用Secret**


&ensp; &ensp; K8S中Pod中使用Secret有两种方式，一是Volume方式，二是环境变量的方式。

&ensp; &ensp; **1. Volume方式**：创建Secret后，将Secret挂载到Pod的volume中，通过volume挂载的方式，将Secret中的信息映射到Pod中。容器必须通过文件读取数据
```
apiVersion: v1
kind: Pod
metadata:
  name: secret-demo-pod
spec:
  containers:
  - name: secret-demo-pod
    image: busybox
    args:
    - /bin/sh
    - -c
    - sleep 10; touch /tmp/healthy; sleep 30000
    volumeMounts:
    - name: foo
      mountPath: "/etc/foo"
      readOnly: true
  volumes:
  - name: foo
    secret:
      secretName: mysecret
```
该Pod中会使用到刚刚定义的secret（mysecret），然后volumeMounts定义了将foo mount到容器中的路径为/etc/foo的目录下，并且指定了读写权限为只读。容器中的/etc/foo目录下会存在secret的文件，通过文件读取方式，将secret中的信息映射到容器中。

&ensp; &ensp; **自定义存放数据的文件名**
```
apiVersion: v1
kind: Pod
metadata:
  name: secret-demo-pod
spec:
  containers:
  - name: secret-demo-pod
    image: busybox
    args:
    - /bin/sh
    - -c
    - sleep 10; touch /tmp/healthy; sleep 30000
    volumeMounts:
    - name: foo
      mountPath: "/etc/foo"
      readOnly: true
  volumes:
  - name: foo
     secret:
      secretName: edc-secret
      items:
      - key: username
        path: /my-group/username
      - key: password
        path: /my-group/password
```


&ensp; &ensp; **2. 环境变量⽅式**：通过Volume使用Secret看起来稍微麻烦了一点，容器必须通过文件读取数据。K8S提供了另外一种方式，那就是环境变量方式
```
apiVersion: v1
kind: Pod
metadata:
  name: secret-demo-pod
spec:
  containers:
  - name: secret-demo-pod
    image: busybox
    args:
    - /bin/sh
    - -c
    - sleep 10; touch /tmp/healthy; sleep 30000
    env:
      - name: MY_SECRET_USERNAME
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: username
      - name: MY_SECRET_PASSWORD
        valueFrom:
          secretKeyRef:
            name: mysecret
            key: password
```
**通过环境变量SECRET_USERNAME和SECRET_PASSWORD成功读取到Secret的数据。
需要注意的是，环境变量读取Secret很方便，但无法支撑Secret动态更新。**
